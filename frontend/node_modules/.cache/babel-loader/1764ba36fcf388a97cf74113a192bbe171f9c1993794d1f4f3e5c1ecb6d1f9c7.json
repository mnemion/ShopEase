{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\COM-LM\\\\Documents\\\\ShopEase\\\\frontend\\\\src\\\\context\\\\CategoryContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useCallback, useRef } from 'react';\nimport { getCategories } from '../api/products';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CategoryContext = /*#__PURE__*/createContext();\nexport const useCategories = () => {\n  _s();\n  return useContext(CategoryContext);\n};\n_s(useCategories, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const CategoryProvider = ({\n  children\n}) => {\n  _s2();\n  const [categories, setCategories] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const maxReconnectAttempts = 5;\n  const baseReconnectDelay = 3000; // 3초\n\n  const fetchCategories = useCallback(async () => {\n    console.log('카테고리 데이터 로딩 시작...');\n    setIsLoading(true);\n    setError(null);\n    try {\n      // 캐시 방지를 위한 타임스탬프 추가\n      const timestamp = new Date().getTime();\n      console.log(`API 호출: /products/categories/?_t=${timestamp}`);\n      const response = await getCategories({\n        _t: timestamp\n      });\n      console.log('API 응답 전체:', JSON.stringify(response));\n\n      // 응답 형식 검증 강화\n      if (!response) {\n        throw new Error('API 응답이 비어있습니다');\n      }\n      if (typeof response !== 'object') {\n        throw new Error(`API 응답이 객체가 아닙니다: ${typeof response}`);\n      }\n\n      // REST framework의 일반적인 페이지네이션 응답 형식 확인\n      if (!('results' in response)) {\n        // results가 없는 경우 전체 응답을 결과로 사용 (API 형식이 다른 경우)\n        console.log('API 응답에 results 필드가 없습니다. 전체 응답을 사용합니다.');\n        if (Array.isArray(response)) {\n          // 응답이 배열인 경우 그대로 사용\n          const activeMainCategories = response.filter(cat => {\n            if (!cat) return false; // null 체크\n            console.log(`카테고리 ${cat.id}: ${cat.name} - 활성화: ${cat.is_active}, 부모: ${cat.parent}`);\n            return cat.is_active === true && !cat.parent;\n          }).sort((a, b) => (a.order || 0) - (b.order || 0));\n          console.log('필터링된 카테고리:', activeMainCategories);\n          setCategories(activeMainCategories);\n\n          // sessionStorage에 저장\n          try {\n            sessionStorage.setItem('categoryData', JSON.stringify(activeMainCategories));\n            sessionStorage.setItem('categoryTimestamp', timestamp.toString());\n          } catch (storageErr) {\n            console.warn('세션 스토리지 저장 실패:', storageErr);\n          }\n          return;\n        } else {\n          throw new Error(`예상치 못한 API 응답 형식: ${JSON.stringify(response).substring(0, 100)}...`);\n        }\n      }\n      if (!Array.isArray(response.results)) {\n        throw new Error(`API 응답의 results가 배열이 아닙니다: ${typeof response.results}`);\n      }\n\n      // 활성화된 메인 카테고리만 필터링하고, 정렬 순서로 정렬\n      const activeMainCategories = response.results.filter(cat => {\n        if (!cat) return false; // null 체크\n        console.log(`카테고리 ${cat.id}: ${cat.name} - 활성화: ${cat.is_active}, 부모: ${cat.parent}`);\n        return cat.is_active === true && !cat.parent;\n      }).sort((a, b) => (a.order || 0) - (b.order || 0));\n      console.log('필터링된 카테고리:', activeMainCategories);\n\n      // 빈 배열이라도 상태 업데이트 진행 (삭제된 경우 반영)\n      setCategories(activeMainCategories);\n\n      // sessionStorage에 최신 데이터와 타임스탬프 저장\n      try {\n        sessionStorage.setItem('categoryData', JSON.stringify(activeMainCategories));\n        sessionStorage.setItem('categoryTimestamp', timestamp.toString());\n        console.log('세션 스토리지에 카테고리 데이터 저장됨');\n      } catch (storageErr) {\n        console.warn('세션 스토리지 저장 실패:', storageErr);\n      }\n    } catch (err) {\n      const errorMessage = `카테고리 로드 실패: ${err.message}`;\n      setError(errorMessage);\n      console.error('카테고리 로드 중 오류 발생:', err);\n\n      // 오류 발생 시 세션 스토리지의 백업 데이터 사용 시도\n      try {\n        const cachedData = sessionStorage.getItem('categoryData');\n        if (cachedData) {\n          console.log('세션 스토리지에서 백업 데이터 복원');\n          setCategories(JSON.parse(cachedData));\n        }\n      } catch (storageErr) {\n        console.warn('세션 스토리지 읽기 실패:', storageErr);\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // 초기 로드\n  useEffect(() => {\n    fetchCategories();\n  }, [fetchCategories]);\n\n  // WebSocket 연결 함수\n  const connectWebSocket = useCallback(() => {\n    // 이미 연결되어 있으면 중복 연결 방지\n    if (wsRef.current && [WebSocket.OPEN, WebSocket.CONNECTING].includes(wsRef.current.readyState)) {\n      console.log('WebSocket 이미 연결됨, 중복 연결 방지');\n      return;\n    }\n\n    // 현재 프로토콜에 맞게 WebSocket 프로토콜 사용 (https -> wss, http -> ws)\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${protocol}//${window.location.hostname}:8000/ws/category-updates/`;\n    console.log('WebSocket 연결 시도:', wsUrl);\n    try {\n      // 이전 연결 정리\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n\n      // 새 WebSocket 연결 생성\n      wsRef.current = new WebSocket(wsUrl);\n      wsRef.current.onopen = () => {\n        console.log('카테고리 WebSocket 연결됨');\n        setIsConnected(true);\n        reconnectAttempts.current = 0; // 연결 성공 시 재시도 카운터 초기화\n\n        // 정기적인 Ping 메시지 전송 설정 (연결 유지 목적)\n        const pingInterval = setInterval(() => {\n          if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n            wsRef.current.send(JSON.stringify({\n              type: 'ping'\n            }));\n          } else {\n            clearInterval(pingInterval);\n          }\n        }, 30000); // 30초마다 ping\n\n        // 컴포넌트가 언마운트될 때 clearInterval이 실행되도록 wsRef에 저장\n        wsRef.current.pingInterval = pingInterval;\n\n        // 연결 후 즉시 카테고리 데이터 새로고침\n        console.log('WebSocket 연결 성공 후 카테고리 데이터 갱신 시도');\n        fetchCategories();\n      };\n      wsRef.current.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          console.log('카테고리 WebSocket 메시지:', data);\n          if (data.type === 'category_update') {\n            const {\n              action,\n              id,\n              name\n            } = data.payload;\n            console.log(`카테고리 변경: ${action}, ID: ${id}, 이름: ${name || '알 수 없음'}`);\n\n            // 카테고리 즉시 상태 업데이트 (더 효율적인 방식)\n            if (action === 'delete') {\n              // 삭제된 카테고리를 즉시 제거 (API 호출 없이)\n              console.log(`ID ${id} 카테고리 즉시 상태에서 제거`);\n              setCategories(prevCategories => prevCategories.filter(category => category.id !== id));\n            } else {\n              // 추가/수정 시에는 전체 목록 새로고침\n              console.log('카테고리 변경 감지로 데이터 갱신 중...');\n              fetchCategories();\n            }\n          } else if (data.type === 'connection_established') {\n            console.log('서버에서 연결 확인 메시지 수신:', data.message);\n            // 연결 후 즉시 카테고리 데이터 새로고침\n            fetchCategories();\n          } else if (data.type === 'pong') {\n            console.log('서버에서 pong 수신');\n          } else if (data.type === 'categories_list') {\n            console.log('서버에서 현재 카테고리 목록 수신:', data.categories);\n            if (Array.isArray(data.categories) && data.categories.length > 0) {\n              // 서버에서 받은 카테고리 목록으로 완전히 대체 (신뢰할 수 있는 소스)\n              const activeMainCategories = data.categories.filter(cat => {\n                console.log(`서버 카테고리 ${cat.id}: ${cat.name} - 활성화: ${cat.is_active}`);\n                return cat.is_active && !cat.parent;\n              }).sort((a, b) => (a.order || 0) - (b.order || 0));\n              console.log('서버 데이터로 필터링된 카테고리:', activeMainCategories);\n\n              // 서버에서 받은 데이터로 항상 상태 갱신\n              setCategories(activeMainCategories);\n              console.log('카테고리 상태 갱신 완료 - 서버 데이터 기준');\n            }\n          }\n        } catch (e) {\n          console.error(\"WebSocket 메시지 파싱 실패:\", e);\n        }\n      };\n      wsRef.current.onerror = error => {\n        var _wsRef$current;\n        console.error('카테고리 WebSocket 오류:', error);\n        console.log('WebSocket 상태:', (_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState);\n        setIsConnected(false);\n      };\n      wsRef.current.onclose = event => {\n        console.log('카테고리 WebSocket 연결 종료, 코드:', event.code, '이유:', event.reason);\n        setIsConnected(false);\n\n        // 정기적인 ping 타이머 정리\n        if (wsRef.current && wsRef.current.pingInterval) {\n          clearInterval(wsRef.current.pingInterval);\n        }\n\n        // 비정상적인 종료인 경우 재연결 시도 (1000은 정상 종료)\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\n          const delay = Math.min(baseReconnectDelay * Math.pow(1.5, reconnectAttempts.current), 30000);\n          console.log(`${delay}ms 후 WebSocket 재연결 시도... (${reconnectAttempts.current + 1}/${maxReconnectAttempts})`);\n\n          // 이전 타임아웃 정리\n          if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n          }\n          reconnectAttempts.current += 1;\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connectWebSocket(); // 재연결 시도\n          }, delay);\n        }\n      };\n    } catch (error) {\n      console.error('WebSocket 인스턴스 생성 오류:', error);\n      setIsConnected(false);\n    }\n  }, [fetchCategories]);\n\n  // WebSocket 연결 및 정리\n  useEffect(() => {\n    // 초기 연결\n    connectWebSocket();\n\n    // 컴포넌트 언마운트 시 정리\n    return () => {\n      // 재연결 타임아웃 정리\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n\n      // 웹소켓 정리\n      if (wsRef.current) {\n        // 정기적인 ping 타이머 정리\n        if (wsRef.current.pingInterval) {\n          clearInterval(wsRef.current.pingInterval);\n        }\n\n        // 연결 종료\n        if (wsRef.current.readyState === WebSocket.OPEN) {\n          console.log('WebSocket 연결 정리 중...');\n          wsRef.current.close();\n        }\n      }\n    };\n  }, [connectWebSocket]);\n\n  // 로컬 스토리지를 정리하는 함수 추가\n  const clearLocalStorage = useCallback(() => {\n    try {\n      console.log('캐시 정리 시작...');\n\n      // 카테고리 관련 로컬 스토리지 항목 삭제\n      localStorage.removeItem('categories');\n      localStorage.removeItem('categoriesLastFetched');\n\n      // 세션 스토리지 항목 삭제\n      sessionStorage.removeItem('categoryData');\n      sessionStorage.removeItem('categoryTimestamp');\n\n      // 캐시된 API 응답도 제거하기 위해 캐시 스토리지 정리 시도\n      if ('caches' in window) {\n        caches.keys().then(cacheNames => {\n          cacheNames.forEach(cacheName => {\n            if (cacheName.includes('category') || cacheName.includes('api')) {\n              caches.delete(cacheName).then(() => console.log(`캐시 ${cacheName} 삭제됨`)).catch(err => console.warn(`캐시 ${cacheName} 삭제 실패:`, err));\n            }\n          });\n        }).catch(err => console.warn('캐시 정리 실패:', err));\n      }\n      console.log('캐시 항목 삭제 완료');\n\n      // 카테고리 데이터 다시 로드\n      console.log('카테고리 데이터 새로 로드 중...');\n      setCategories([]); // 먼저 상태 비우기\n      fetchCategories();\n    } catch (error) {\n      console.error('캐시 정리 중 오류:', error);\n    }\n  }, [fetchCategories]);\n  return /*#__PURE__*/_jsxDEV(CategoryContext.Provider, {\n    value: {\n      categories,\n      isLoading,\n      error,\n      fetchCategories,\n      isConnected,\n      reconnect: connectWebSocket,\n      clearLocalStorage\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 318,\n    columnNumber: 5\n  }, this);\n};\n_s2(CategoryProvider, \"CC6Vffou3za9opngfGG92d5CrLE=\");\n_c = CategoryProvider;\nvar _c;\n$RefreshReg$(_c, \"CategoryProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useCallback","useRef","getCategories","jsxDEV","_jsxDEV","CategoryContext","useCategories","_s","CategoryProvider","children","_s2","categories","setCategories","isLoading","setIsLoading","error","setError","isConnected","setIsConnected","wsRef","reconnectTimeoutRef","reconnectAttempts","maxReconnectAttempts","baseReconnectDelay","fetchCategories","console","log","timestamp","Date","getTime","response","_t","JSON","stringify","Error","Array","isArray","activeMainCategories","filter","cat","id","name","is_active","parent","sort","a","b","order","sessionStorage","setItem","toString","storageErr","warn","substring","results","err","errorMessage","message","cachedData","getItem","parse","connectWebSocket","current","WebSocket","OPEN","CONNECTING","includes","readyState","protocol","window","location","wsUrl","hostname","close","onopen","pingInterval","setInterval","send","type","clearInterval","onmessage","event","data","action","payload","prevCategories","category","length","e","onerror","_wsRef$current","onclose","code","reason","delay","Math","min","pow","clearTimeout","setTimeout","clearLocalStorage","localStorage","removeItem","caches","keys","then","cacheNames","forEach","cacheName","delete","catch","Provider","value","reconnect","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/COM-LM/Documents/ShopEase/frontend/src/context/CategoryContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useCallback, useRef } from 'react';\r\nimport { getCategories } from '../api/products';\r\n\r\nconst CategoryContext = createContext();\r\n\r\nexport const useCategories = () => useContext(CategoryContext);\r\n\r\nexport const CategoryProvider = ({ children }) => {\r\n  const [categories, setCategories] = useState([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const wsRef = useRef(null);\r\n  const reconnectTimeoutRef = useRef(null);\r\n  const reconnectAttempts = useRef(0);\r\n  const maxReconnectAttempts = 5;\r\n  const baseReconnectDelay = 3000; // 3초\r\n\r\n  const fetchCategories = useCallback(async () => {\r\n    console.log('카테고리 데이터 로딩 시작...');\r\n    setIsLoading(true);\r\n    setError(null);\r\n    try {\r\n      // 캐시 방지를 위한 타임스탬프 추가\r\n      const timestamp = new Date().getTime();\r\n      console.log(`API 호출: /products/categories/?_t=${timestamp}`);\r\n      const response = await getCategories({ _t: timestamp });\r\n      console.log('API 응답 전체:', JSON.stringify(response));\r\n      \r\n      // 응답 형식 검증 강화\r\n      if (!response) {\r\n        throw new Error('API 응답이 비어있습니다');\r\n      }\r\n      \r\n      if (typeof response !== 'object') {\r\n        throw new Error(`API 응답이 객체가 아닙니다: ${typeof response}`);\r\n      }\r\n      \r\n      // REST framework의 일반적인 페이지네이션 응답 형식 확인\r\n      if (!('results' in response)) {\r\n        // results가 없는 경우 전체 응답을 결과로 사용 (API 형식이 다른 경우)\r\n        console.log('API 응답에 results 필드가 없습니다. 전체 응답을 사용합니다.');\r\n        \r\n        if (Array.isArray(response)) {\r\n          // 응답이 배열인 경우 그대로 사용\r\n          const activeMainCategories = response\r\n            .filter(cat => {\r\n              if (!cat) return false; // null 체크\r\n              console.log(`카테고리 ${cat.id}: ${cat.name} - 활성화: ${cat.is_active}, 부모: ${cat.parent}`);\r\n              return cat.is_active === true && !cat.parent;\r\n            })\r\n            .sort((a, b) => (a.order || 0) - (b.order || 0));\r\n          \r\n          console.log('필터링된 카테고리:', activeMainCategories);\r\n          setCategories(activeMainCategories);\r\n          \r\n          // sessionStorage에 저장\r\n          try {\r\n            sessionStorage.setItem('categoryData', JSON.stringify(activeMainCategories));\r\n            sessionStorage.setItem('categoryTimestamp', timestamp.toString());\r\n          } catch (storageErr) {\r\n            console.warn('세션 스토리지 저장 실패:', storageErr);\r\n          }\r\n          return;\r\n        } else {\r\n          throw new Error(`예상치 못한 API 응답 형식: ${JSON.stringify(response).substring(0, 100)}...`);\r\n        }\r\n      }\r\n      \r\n      if (!Array.isArray(response.results)) {\r\n        throw new Error(`API 응답의 results가 배열이 아닙니다: ${typeof response.results}`);\r\n      }\r\n      \r\n      // 활성화된 메인 카테고리만 필터링하고, 정렬 순서로 정렬\r\n      const activeMainCategories = response.results\r\n        .filter(cat => {\r\n          if (!cat) return false; // null 체크\r\n          console.log(`카테고리 ${cat.id}: ${cat.name} - 활성화: ${cat.is_active}, 부모: ${cat.parent}`);\r\n          return cat.is_active === true && !cat.parent;\r\n        })\r\n        .sort((a, b) => (a.order || 0) - (b.order || 0));\r\n      \r\n      console.log('필터링된 카테고리:', activeMainCategories);\r\n      \r\n      // 빈 배열이라도 상태 업데이트 진행 (삭제된 경우 반영)\r\n      setCategories(activeMainCategories);\r\n      \r\n      // sessionStorage에 최신 데이터와 타임스탬프 저장\r\n      try {\r\n        sessionStorage.setItem('categoryData', JSON.stringify(activeMainCategories));\r\n        sessionStorage.setItem('categoryTimestamp', timestamp.toString());\r\n        console.log('세션 스토리지에 카테고리 데이터 저장됨');\r\n      } catch (storageErr) {\r\n        console.warn('세션 스토리지 저장 실패:', storageErr);\r\n      }\r\n    } catch (err) {\r\n      const errorMessage = `카테고리 로드 실패: ${err.message}`;\r\n      setError(errorMessage);\r\n      console.error('카테고리 로드 중 오류 발생:', err);\r\n      \r\n      // 오류 발생 시 세션 스토리지의 백업 데이터 사용 시도\r\n      try {\r\n        const cachedData = sessionStorage.getItem('categoryData');\r\n        if (cachedData) {\r\n          console.log('세션 스토리지에서 백업 데이터 복원');\r\n          setCategories(JSON.parse(cachedData));\r\n        }\r\n      } catch (storageErr) {\r\n        console.warn('세션 스토리지 읽기 실패:', storageErr);\r\n      }\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // 초기 로드\r\n  useEffect(() => {\r\n    fetchCategories();\r\n  }, [fetchCategories]);\r\n\r\n  // WebSocket 연결 함수\r\n  const connectWebSocket = useCallback(() => {\r\n    // 이미 연결되어 있으면 중복 연결 방지\r\n    if (wsRef.current && [WebSocket.OPEN, WebSocket.CONNECTING].includes(wsRef.current.readyState)) {\r\n      console.log('WebSocket 이미 연결됨, 중복 연결 방지');\r\n      return;\r\n    }\r\n\r\n    // 현재 프로토콜에 맞게 WebSocket 프로토콜 사용 (https -> wss, http -> ws)\r\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n    const wsUrl = `${protocol}//${window.location.hostname}:8000/ws/category-updates/`;\r\n    console.log('WebSocket 연결 시도:', wsUrl);\r\n    \r\n    try {\r\n      // 이전 연결 정리\r\n      if (wsRef.current) {\r\n        wsRef.current.close();\r\n      }\r\n      \r\n      // 새 WebSocket 연결 생성\r\n      wsRef.current = new WebSocket(wsUrl);\r\n      \r\n      wsRef.current.onopen = () => {\r\n        console.log('카테고리 WebSocket 연결됨');\r\n        setIsConnected(true);\r\n        reconnectAttempts.current = 0; // 연결 성공 시 재시도 카운터 초기화\r\n        \r\n        // 정기적인 Ping 메시지 전송 설정 (연결 유지 목적)\r\n        const pingInterval = setInterval(() => {\r\n          if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\r\n            wsRef.current.send(JSON.stringify({ type: 'ping' }));\r\n          } else {\r\n            clearInterval(pingInterval);\r\n          }\r\n        }, 30000); // 30초마다 ping\r\n        \r\n        // 컴포넌트가 언마운트될 때 clearInterval이 실행되도록 wsRef에 저장\r\n        wsRef.current.pingInterval = pingInterval;\r\n        \r\n        // 연결 후 즉시 카테고리 데이터 새로고침\r\n        console.log('WebSocket 연결 성공 후 카테고리 데이터 갱신 시도');\r\n        fetchCategories();\r\n      };\r\n\r\n      wsRef.current.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          console.log('카테고리 WebSocket 메시지:', data);\r\n\r\n          if (data.type === 'category_update') {\r\n            const { action, id, name } = data.payload;\r\n            console.log(`카테고리 변경: ${action}, ID: ${id}, 이름: ${name || '알 수 없음'}`);\r\n            \r\n            // 카테고리 즉시 상태 업데이트 (더 효율적인 방식)\r\n            if (action === 'delete') {\r\n              // 삭제된 카테고리를 즉시 제거 (API 호출 없이)\r\n              console.log(`ID ${id} 카테고리 즉시 상태에서 제거`);\r\n              setCategories(prevCategories => \r\n                prevCategories.filter(category => category.id !== id)\r\n              );\r\n            } else {\r\n              // 추가/수정 시에는 전체 목록 새로고침\r\n              console.log('카테고리 변경 감지로 데이터 갱신 중...');\r\n              fetchCategories();\r\n            }\r\n          } else if (data.type === 'connection_established') {\r\n            console.log('서버에서 연결 확인 메시지 수신:', data.message);\r\n            // 연결 후 즉시 카테고리 데이터 새로고침\r\n            fetchCategories();\r\n          } else if (data.type === 'pong') {\r\n            console.log('서버에서 pong 수신');\r\n          } else if (data.type === 'categories_list') {\r\n            console.log('서버에서 현재 카테고리 목록 수신:', data.categories);\r\n            if (Array.isArray(data.categories) && data.categories.length > 0) {\r\n              // 서버에서 받은 카테고리 목록으로 완전히 대체 (신뢰할 수 있는 소스)\r\n              const activeMainCategories = data.categories\r\n                .filter(cat => {\r\n                  console.log(`서버 카테고리 ${cat.id}: ${cat.name} - 활성화: ${cat.is_active}`);\r\n                  return cat.is_active && !cat.parent;\r\n                })\r\n                .sort((a, b) => (a.order || 0) - (b.order || 0));\r\n              \r\n              console.log('서버 데이터로 필터링된 카테고리:', activeMainCategories);\r\n              \r\n              // 서버에서 받은 데이터로 항상 상태 갱신\r\n              setCategories(activeMainCategories);\r\n              console.log('카테고리 상태 갱신 완료 - 서버 데이터 기준');\r\n            }\r\n          }\r\n        } catch (e) {\r\n          console.error(\"WebSocket 메시지 파싱 실패:\", e);\r\n        }\r\n      };\r\n\r\n      wsRef.current.onerror = (error) => {\r\n        console.error('카테고리 WebSocket 오류:', error);\r\n        console.log('WebSocket 상태:', wsRef.current?.readyState);\r\n        setIsConnected(false);\r\n      };\r\n\r\n      wsRef.current.onclose = (event) => {\r\n        console.log('카테고리 WebSocket 연결 종료, 코드:', event.code, '이유:', event.reason);\r\n        setIsConnected(false);\r\n        \r\n        // 정기적인 ping 타이머 정리\r\n        if (wsRef.current && wsRef.current.pingInterval) {\r\n          clearInterval(wsRef.current.pingInterval);\r\n        }\r\n        \r\n        // 비정상적인 종료인 경우 재연결 시도 (1000은 정상 종료)\r\n        if (event.code !== 1000 && reconnectAttempts.current < maxReconnectAttempts) {\r\n          const delay = Math.min(baseReconnectDelay * Math.pow(1.5, reconnectAttempts.current), 30000);\r\n          console.log(`${delay}ms 후 WebSocket 재연결 시도... (${reconnectAttempts.current + 1}/${maxReconnectAttempts})`);\r\n          \r\n          // 이전 타임아웃 정리\r\n          if (reconnectTimeoutRef.current) {\r\n            clearTimeout(reconnectTimeoutRef.current);\r\n          }\r\n          \r\n          reconnectAttempts.current += 1;\r\n          reconnectTimeoutRef.current = setTimeout(() => {\r\n            connectWebSocket(); // 재연결 시도\r\n          }, delay);\r\n        }\r\n      };\r\n    } catch (error) {\r\n      console.error('WebSocket 인스턴스 생성 오류:', error);\r\n      setIsConnected(false);\r\n    }\r\n  }, [fetchCategories]);\r\n\r\n  // WebSocket 연결 및 정리\r\n  useEffect(() => {\r\n    // 초기 연결\r\n    connectWebSocket();\r\n    \r\n    // 컴포넌트 언마운트 시 정리\r\n    return () => {\r\n      // 재연결 타임아웃 정리\r\n      if (reconnectTimeoutRef.current) {\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n      }\r\n      \r\n      // 웹소켓 정리\r\n      if (wsRef.current) {\r\n        // 정기적인 ping 타이머 정리\r\n        if (wsRef.current.pingInterval) {\r\n          clearInterval(wsRef.current.pingInterval);\r\n        }\r\n        \r\n        // 연결 종료\r\n        if (wsRef.current.readyState === WebSocket.OPEN) {\r\n          console.log('WebSocket 연결 정리 중...');\r\n          wsRef.current.close();\r\n        }\r\n      }\r\n    };\r\n  }, [connectWebSocket]);\r\n\r\n  // 로컬 스토리지를 정리하는 함수 추가\r\n  const clearLocalStorage = useCallback(() => {\r\n    try {\r\n      console.log('캐시 정리 시작...');\r\n      \r\n      // 카테고리 관련 로컬 스토리지 항목 삭제\r\n      localStorage.removeItem('categories');\r\n      localStorage.removeItem('categoriesLastFetched');\r\n      \r\n      // 세션 스토리지 항목 삭제\r\n      sessionStorage.removeItem('categoryData');\r\n      sessionStorage.removeItem('categoryTimestamp');\r\n      \r\n      // 캐시된 API 응답도 제거하기 위해 캐시 스토리지 정리 시도\r\n      if ('caches' in window) {\r\n        caches.keys().then(cacheNames => {\r\n          cacheNames.forEach(cacheName => {\r\n            if (cacheName.includes('category') || cacheName.includes('api')) {\r\n              caches.delete(cacheName)\r\n                .then(() => console.log(`캐시 ${cacheName} 삭제됨`))\r\n                .catch(err => console.warn(`캐시 ${cacheName} 삭제 실패:`, err));\r\n            }\r\n          });\r\n        }).catch(err => console.warn('캐시 정리 실패:', err));\r\n      }\r\n      \r\n      console.log('캐시 항목 삭제 완료');\r\n      \r\n      // 카테고리 데이터 다시 로드\r\n      console.log('카테고리 데이터 새로 로드 중...');\r\n      setCategories([]); // 먼저 상태 비우기\r\n      fetchCategories();\r\n    } catch (error) {\r\n      console.error('캐시 정리 중 오류:', error);\r\n    }\r\n  }, [fetchCategories]);\r\n\r\n  return (\r\n    <CategoryContext.Provider \r\n      value={{ \r\n        categories, \r\n        isLoading, \r\n        error, \r\n        fetchCategories, \r\n        isConnected, \r\n        reconnect: connectWebSocket,\r\n        clearLocalStorage\r\n      }}\r\n    >\r\n      {children}\r\n    </CategoryContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}