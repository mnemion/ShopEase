{"ast":null,"code":"import axios from 'axios';\n\n// 기본 API 클라이언트 설정\nconst apiClient = axios.create({\n  baseURL: process.env.REACT_APP_API_URL || `http://${window.location.hostname}:8000/api`,\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// 토큰 갱신 요청을 위한 별도 인스턴스 (무한 루프 방지)\nconst refreshClient = axios.create({\n  baseURL: process.env.REACT_APP_API_URL || `http://${window.location.hostname}:8000/api`,\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n});\n\n// 토큰 갱신 함수\nconst refreshAccessToken = async () => {\n  try {\n    const refreshToken = localStorage.getItem('refresh_token');\n    if (!refreshToken) throw new Error('No refresh token available');\n    const response = await refreshClient.post('/users/token/refresh/', {\n      refresh: refreshToken\n    });\n    const {\n      access\n    } = response.data;\n    localStorage.setItem('access_token', access);\n    return access;\n  } catch (error) {\n    localStorage.removeItem('access_token');\n    localStorage.removeItem('refresh_token');\n    throw error;\n  }\n};\n\n// 토큰 갱신 중인지 추적\nlet isRefreshing = false;\n// 토큰 갱신을 기다리는 요청 대기열\nlet refreshSubscribers = [];\n\n// 토큰 갱신 완료 후 대기 중인 요청들 처리\nconst onRefreshed = token => {\n  refreshSubscribers.forEach(callback => callback(token));\n  refreshSubscribers = [];\n};\n\n// 토큰 갱신 시 대기열에 요청 추가\nconst addSubscriber = callback => {\n  refreshSubscribers.push(callback);\n};\n\n// 토큰이 있으면 요청 헤더에 추가하는 인터셉터\napiClient.interceptors.request.use(config => {\n  const token = localStorage.getItem('access_token');\n  if (token) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// 응답 인터셉터 - 토큰 갱신, 에러 처리 등\napiClient.interceptors.response.use(response => {\n  return response;\n}, async error => {\n  const originalRequest = error.config;\n\n  // 401 에러이고, 이미 재시도를 하지 않았으며, 토큰이 있는 경우에만 시도\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    if (isRefreshing) {\n      // 이미 다른 요청이 토큰을 갱신 중인 경우, 대기열에 추가하고 갱신 완료 대기\n      try {\n        const newToken = await new Promise((resolve, reject) => {\n          addSubscriber(token => {\n            resolve(token);\n          });\n        });\n        originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\n        return apiClient(originalRequest);\n      } catch (refreshError) {\n        return Promise.reject(refreshError);\n      }\n    }\n\n    // 토큰 갱신 시작\n    originalRequest._retry = true;\n    isRefreshing = true;\n    try {\n      const newToken = await refreshAccessToken();\n\n      // 갱신된 토큰으로 대기 중인 요청들 처리\n      onRefreshed(newToken);\n\n      // 원래 요청 다시 시도\n      originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\n      isRefreshing = false;\n      return apiClient(originalRequest);\n    } catch (refreshError) {\n      isRefreshing = false;\n\n      // 로그인 페이지로 리다이렉트 - 필요하면 활성화\n      // window.location.href = '/login';\n\n      return Promise.reject(refreshError);\n    }\n  }\n  return Promise.reject(error);\n});\nexport default apiClient;","map":{"version":3,"names":["axios","apiClient","create","baseURL","process","env","REACT_APP_API_URL","window","location","hostname","timeout","headers","refreshClient","refreshAccessToken","refreshToken","localStorage","getItem","Error","response","post","refresh","access","data","setItem","error","removeItem","isRefreshing","refreshSubscribers","onRefreshed","token","forEach","callback","addSubscriber","push","interceptors","request","use","config","Promise","reject","originalRequest","status","_retry","newToken","resolve","refreshError"],"sources":["C:/Users/COM-LM/Documents/ShopEase/frontend/src/api/client.js"],"sourcesContent":["import axios from 'axios';\r\n\r\n// 기본 API 클라이언트 설정\r\nconst apiClient = axios.create({\r\n  baseURL: process.env.REACT_APP_API_URL || `http://${window.location.hostname}:8000/api`,\r\n  timeout: 10000,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n    'Accept': 'application/json',\r\n  }\r\n});\r\n\r\n// 토큰 갱신 요청을 위한 별도 인스턴스 (무한 루프 방지)\r\nconst refreshClient = axios.create({\r\n  baseURL: process.env.REACT_APP_API_URL || `http://${window.location.hostname}:8000/api`,\r\n  timeout: 10000,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n    'Accept': 'application/json',\r\n  }\r\n});\r\n\r\n// 토큰 갱신 함수\r\nconst refreshAccessToken = async () => {\r\n  try {\r\n    const refreshToken = localStorage.getItem('refresh_token');\r\n    if (!refreshToken) throw new Error('No refresh token available');\r\n    \r\n    const response = await refreshClient.post('/users/token/refresh/', { refresh: refreshToken });\r\n    const { access } = response.data;\r\n    \r\n    localStorage.setItem('access_token', access);\r\n    return access;\r\n  } catch (error) {\r\n    localStorage.removeItem('access_token');\r\n    localStorage.removeItem('refresh_token');\r\n    throw error;\r\n  }\r\n};\r\n\r\n// 토큰 갱신 중인지 추적\r\nlet isRefreshing = false;\r\n// 토큰 갱신을 기다리는 요청 대기열\r\nlet refreshSubscribers = [];\r\n\r\n// 토큰 갱신 완료 후 대기 중인 요청들 처리\r\nconst onRefreshed = (token) => {\r\n  refreshSubscribers.forEach(callback => callback(token));\r\n  refreshSubscribers = [];\r\n};\r\n\r\n// 토큰 갱신 시 대기열에 요청 추가\r\nconst addSubscriber = (callback) => {\r\n  refreshSubscribers.push(callback);\r\n};\r\n\r\n// 토큰이 있으면 요청 헤더에 추가하는 인터셉터\r\napiClient.interceptors.request.use(\r\n  (config) => {\r\n    const token = localStorage.getItem('access_token');\r\n    if (token) {\r\n      config.headers['Authorization'] = `Bearer ${token}`;\r\n    }\r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// 응답 인터셉터 - 토큰 갱신, 에러 처리 등\r\napiClient.interceptors.response.use(\r\n  (response) => {\r\n    return response;\r\n  },\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n    \r\n    // 401 에러이고, 이미 재시도를 하지 않았으며, 토큰이 있는 경우에만 시도\r\n    if (error.response && error.response.status === 401 && !originalRequest._retry) {\r\n      if (isRefreshing) {\r\n        // 이미 다른 요청이 토큰을 갱신 중인 경우, 대기열에 추가하고 갱신 완료 대기\r\n        try {\r\n          const newToken = await new Promise((resolve, reject) => {\r\n            addSubscriber(token => {\r\n              resolve(token);\r\n            });\r\n          });\r\n          originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\r\n          return apiClient(originalRequest);\r\n        } catch (refreshError) {\r\n          return Promise.reject(refreshError);\r\n        }\r\n      }\r\n      \r\n      // 토큰 갱신 시작\r\n      originalRequest._retry = true;\r\n      isRefreshing = true;\r\n      \r\n      try {\r\n        const newToken = await refreshAccessToken();\r\n        \r\n        // 갱신된 토큰으로 대기 중인 요청들 처리\r\n        onRefreshed(newToken);\r\n        \r\n        // 원래 요청 다시 시도\r\n        originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\r\n        isRefreshing = false;\r\n        return apiClient(originalRequest);\r\n      } catch (refreshError) {\r\n        isRefreshing = false;\r\n        \r\n        // 로그인 페이지로 리다이렉트 - 필요하면 활성화\r\n        // window.location.href = '/login';\r\n        \r\n        return Promise.reject(refreshError);\r\n      }\r\n    }\r\n    \r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default apiClient;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}